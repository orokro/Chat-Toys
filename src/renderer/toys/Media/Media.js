/*
	Media.js
	--------

	This class handles the state for the Media toy system.

	NOTE: it does not handle the rendering, which will be the widgets.
*/

// vue
import { ref, shallowRef, watch } from 'vue';
import { socketRef, socketShallowRef, socketShallowRefAsync, bindRef } from 'socket-ref';

// our app
import Toy from "../Toy";
import { StateTickerQueue } from '@scripts/StateTickerQueue';

// components
import MediaPage from './MediaPage.vue';
import MediaWidget from './MediaWidget.vue';

// main export
export default class Media extends Toy {

	// static info
	static name = 'Media';
	static slug = 'media';
	static desc = 'Display images, GIFs, or play sounds on your stream.';
	static optionsPageComponent = MediaPage;
	static themeColor = '#51547D';
	static widgetComponents = [
		{
			component: MediaWidget,
			key: 'widgetBox',
			allowResize: true,
			lockAspectRatio: false,
			description: 'Shows a picture, gif, and plays a sound. Can be placed anywhere.',
			slug: 'mediaBox'
		}
	];


	/**
	 * Constructs the Media object
	 * 
	 * @param {ToyManager} toyManager - reference to the toy manager
	 */
	constructor(toyManager) {

		// call the parent constructor
		super(toyManager);

		// our state ticker queue
		this.stateTickerQueue = new StateTickerQueue(this.handleStateChange.bind(this), 2, 5);
		this.tickFN = () => this.stateTickerQueue.tick()
		electronAPI.tick(this.tickFN);

		// live socket settings
		this.mode = socketShallowRef(this.static.slugify('mode'), 'IDLE');
		this.message = socketShallowRef(this.static.slugify('message'), '');
		this.soundPath = socketShallowRef(this.static.slugify('soundPath'), null);
		this.imagePath = socketShallowRef(this.static.slugify('imagePath'), null);

	}


	/**
	 * Perform clean up when the toy is destroyed
	 */
	end(){
		super.end();
		electronAPI.clearTick(this.tickFN);
		if(this.stateTimeout)
			window.clearTimeout(this.stateTimeout);
	}


	/**
	 * Initialize the settings for this toy
	 */
	initSettings() {

		// media settings
		this.buildSettingsBlock({

			mediaAssets: shallowRef([]),
			widgetBox: shallowRef({
				x: 20,
				y: 20,
				width: 400,
				height: 200
			}),			
		});
	}


	/**
	 * Initialize the commands for this toy
	 */
	buildCommands() {

		// all commands on this toy will be generated by the user,
		// so empty array. NOTE: user generated commands will never be
		// added to this array, get them through the commands ref
		super.buildCommands([]);
	}
	

	/**
	 * Handle when an incoming command is sent to this toy
	 * 
	 * @param {String} commandSlug - the slug of the command
	 * @param {Object} msg - details about the chat message that invoked the command
	 * @param {Object} user - details about the user that invoked the command (could be dummy if not in database yet)
	 * @param {Array<String>} params - the parameters passed to the command
	 * @param {Object} handshake - object like { accept: Function, reject: Function } to accept or reject the command
	 */
	onCommand(commandSlug, msg, user, params, handshake) {

		// queue the media item & accept the command
		this.queueMediaItem(msg, commandSlug);

		// accept the command which updates the database
		handshake.accept();
	}
	

	/**
	 * Queues a media item when command is run
	 * 
	 * @param {Object} msg - the message object that invoked the command
	 * @param {String} item - the raw media slug i.e. _1, _2, etc
	 */
	queueMediaItem(msg, item) {

		// convert the item to index
		const mediaIndex = parseInt(item, 10)-1;

		// get the media item from the settings
		const mediaAssets = this.settings.mediaAssets.value;
		const mediaItem = mediaAssets[mediaIndex];

		// show on system console
		this.chatToysApp.log.msg(`${msg.author} used media !${mediaItem.commandName}`);

		// repack the media item into a queue item
		const queueItem = {
			message: `${msg.author} used !${mediaItem.commandName}`,
			imagePath: mediaItem.hasImage ? this.getAssetPath(mediaItem.imageId) : null,
			soundPath: mediaItem.hasSound ? this.getAssetPath(mediaItem.soundId) : null,
			duration: mediaItem.duration,
		}
		this.stateTickerQueue.addToQueue(queueItem);
	}


	/**
	 * Pops the next media item from the queue
	 */
	handleStateChange(data) {
		
		// if we got null, return to IDLE
		if(data === null) {
			this.mode.value = 'IDLE';
			return;
		}

		// otherwise, set the media item
		const mediaItem = data;
		this.message.value = mediaItem.message;
		this.soundPath.value = mediaItem.soundPath;
		this.imagePath.value = mediaItem.imagePath;
		this.stateTimeout = window.setElectronTimeout(()=>{
			this.mode.value = 'PLAY';
		}, 100);
	}

}
